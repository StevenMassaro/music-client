/// <reference path="./custom.d.ts" />
// tslint:disable
// @ts-nocheck
/* eslint-disable */
/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://localhost:8080".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface DeferredTrack
 */
export interface DeferredTrack {
    /**
     * 
     * @type {string}
     * @memberof DeferredTrack
     */
    album?: string;
    /**
     * 
     * @type {string}
     * @memberof DeferredTrack
     */
    albumArtist?: string;
    /**
     * 
     * @type {string}
     * @memberof DeferredTrack
     */
    artist?: string;
    /**
     * 
     * @type {number}
     * @memberof DeferredTrack
     */
    bitrate?: number;
    /**
     * 
     * @type {string}
     * @memberof DeferredTrack
     */
    comment?: string;
    /**
     * 
     * @type {Date}
     * @memberof DeferredTrack
     */
    dateCreated?: Date;
    /**
     * 
     * @type {number}
     * @memberof DeferredTrack
     */
    discNo?: number;
    /**
     * 
     * @type {number}
     * @memberof DeferredTrack
     */
    duration?: number;
    /**
     * 
     * @type {string}
     * @memberof DeferredTrack
     */
    encoding?: string;
    /**
     * 
     * @type {string}
     * @memberof DeferredTrack
     */
    genre?: string;
    /**
     * 
     * @type {string}
     * @memberof DeferredTrack
     */
    hash?: string;
    /**
     * 
     * @type {number}
     * @memberof DeferredTrack
     */
    id: number;
    /**
     * 
     * @type {Date}
     * @memberof DeferredTrack
     */
    lastPlayedDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof DeferredTrack
     */
    location?: string;
    /**
     * 
     * @type {number}
     * @memberof DeferredTrack
     */
    plays?: number;
    /**
     * 
     * @type {number}
     * @memberof DeferredTrack
     */
    rating?: number;
    /**
     * 
     * @type {number}
     * @memberof DeferredTrack
     */
    sampleRate?: number;
    /**
     * 
     * @type {number}
     * @memberof DeferredTrack
     */
    skips?: number;
    /**
     * 
     * @type {string}
     * @memberof DeferredTrack
     */
    title?: string;
    /**
     * 
     * @type {number}
     * @memberof DeferredTrack
     */
    track?: number;
    /**
     * 
     * @type {string}
     * @memberof DeferredTrack
     */
    year?: string;
}

/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    artsize?: number;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    bitrate?: number;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    channels?: number;
    /**
     * 
     * @type {Date}
     * @memberof Device
     */
    dateCreated?: Date;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    format?: string;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    sampleRate?: number;
}

/**
 * 
 * @export
 * @interface IItem
 */
export interface IItem {
}

/**
 * 
 * @export
 * @interface InputStream
 */
export interface InputStream {
}

/**
 * 
 * @export
 * @interface ItemImportResult
 */
export interface ItemImportResult {
    /**
     * 
     * @type {Array<IItem>}
     * @memberof ItemImportResult
     */
    alreadyImported: Array<IItem>;
    /**
     * 
     * @type {Array<IItem>}
     * @memberof ItemImportResult
     */
    failed: Array<IItem>;
    /**
     * 
     * @type {Array<IItem>}
     * @memberof ItemImportResult
     */
    successful: Array<IItem>;
}

/**
 * 
 * @export
 * @interface Library
 */
export interface Library {
    /**
     * 
     * @type {number}
     * @memberof Library
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Library
     */
    name: string;
}

/**
 * 
 * @export
 * @interface MigrationResult
 */
export interface MigrationResult {
    /**
     * 
     * @type {ItemImportResult}
     * @memberof MigrationResult
     */
    playCounts: ItemImportResult;
    /**
     * 
     * @type {ItemImportResult}
     * @memberof MigrationResult
     */
    plays: ItemImportResult;
    /**
     * 
     * @type {ItemImportResult}
     * @memberof MigrationResult
     */
    ratings: ItemImportResult;
}

/**
 * 
 * @export
 * @interface ModelAndView
 */
export interface ModelAndView {
    /**
     * 
     * @type {boolean}
     * @memberof ModelAndView
     */
    empty?: boolean;
    /**
     * 
     * @type {any}
     * @memberof ModelAndView
     */
    model?: any;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ModelAndView
     */
    modelMap?: { [key: string]: any; };
    /**
     * 
     * @type {boolean}
     * @memberof ModelAndView
     */
    reference?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelAndView
     */
    status?: ModelAndView.StatusEnum;
    /**
     * 
     * @type {View}
     * @memberof ModelAndView
     */
    view?: View;
    /**
     * 
     * @type {string}
     * @memberof ModelAndView
     */
    viewName?: string;
}

/**
 * @export
 * @namespace ModelAndView
 */
export namespace ModelAndView {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        ACCEPTED = <any> 'ACCEPTED',
        ALREADYREPORTED = <any> 'ALREADY_REPORTED',
        BADGATEWAY = <any> 'BAD_GATEWAY',
        BADREQUEST = <any> 'BAD_REQUEST',
        BANDWIDTHLIMITEXCEEDED = <any> 'BANDWIDTH_LIMIT_EXCEEDED',
        CHECKPOINT = <any> 'CHECKPOINT',
        CONFLICT = <any> 'CONFLICT',
        CONTINUE = <any> 'CONTINUE',
        CREATED = <any> 'CREATED',
        DESTINATIONLOCKED = <any> 'DESTINATION_LOCKED',
        EXPECTATIONFAILED = <any> 'EXPECTATION_FAILED',
        FAILEDDEPENDENCY = <any> 'FAILED_DEPENDENCY',
        FORBIDDEN = <any> 'FORBIDDEN',
        FOUND = <any> 'FOUND',
        GATEWAYTIMEOUT = <any> 'GATEWAY_TIMEOUT',
        GONE = <any> 'GONE',
        HTTPVERSIONNOTSUPPORTED = <any> 'HTTP_VERSION_NOT_SUPPORTED',
        IMUSED = <any> 'IM_USED',
        INSUFFICIENTSPACEONRESOURCE = <any> 'INSUFFICIENT_SPACE_ON_RESOURCE',
        INSUFFICIENTSTORAGE = <any> 'INSUFFICIENT_STORAGE',
        INTERNALSERVERERROR = <any> 'INTERNAL_SERVER_ERROR',
        IAMATEAPOT = <any> 'I_AM_A_TEAPOT',
        LENGTHREQUIRED = <any> 'LENGTH_REQUIRED',
        LOCKED = <any> 'LOCKED',
        LOOPDETECTED = <any> 'LOOP_DETECTED',
        METHODFAILURE = <any> 'METHOD_FAILURE',
        METHODNOTALLOWED = <any> 'METHOD_NOT_ALLOWED',
        MOVEDPERMANENTLY = <any> 'MOVED_PERMANENTLY',
        MOVEDTEMPORARILY = <any> 'MOVED_TEMPORARILY',
        MULTIPLECHOICES = <any> 'MULTIPLE_CHOICES',
        MULTISTATUS = <any> 'MULTI_STATUS',
        NETWORKAUTHENTICATIONREQUIRED = <any> 'NETWORK_AUTHENTICATION_REQUIRED',
        NONAUTHORITATIVEINFORMATION = <any> 'NON_AUTHORITATIVE_INFORMATION',
        NOTACCEPTABLE = <any> 'NOT_ACCEPTABLE',
        NOTEXTENDED = <any> 'NOT_EXTENDED',
        NOTFOUND = <any> 'NOT_FOUND',
        NOTIMPLEMENTED = <any> 'NOT_IMPLEMENTED',
        NOTMODIFIED = <any> 'NOT_MODIFIED',
        NOCONTENT = <any> 'NO_CONTENT',
        OK = <any> 'OK',
        PARTIALCONTENT = <any> 'PARTIAL_CONTENT',
        PAYLOADTOOLARGE = <any> 'PAYLOAD_TOO_LARGE',
        PAYMENTREQUIRED = <any> 'PAYMENT_REQUIRED',
        PERMANENTREDIRECT = <any> 'PERMANENT_REDIRECT',
        PRECONDITIONFAILED = <any> 'PRECONDITION_FAILED',
        PRECONDITIONREQUIRED = <any> 'PRECONDITION_REQUIRED',
        PROCESSING = <any> 'PROCESSING',
        PROXYAUTHENTICATIONREQUIRED = <any> 'PROXY_AUTHENTICATION_REQUIRED',
        REQUESTEDRANGENOTSATISFIABLE = <any> 'REQUESTED_RANGE_NOT_SATISFIABLE',
        REQUESTENTITYTOOLARGE = <any> 'REQUEST_ENTITY_TOO_LARGE',
        REQUESTHEADERFIELDSTOOLARGE = <any> 'REQUEST_HEADER_FIELDS_TOO_LARGE',
        REQUESTTIMEOUT = <any> 'REQUEST_TIMEOUT',
        REQUESTURITOOLONG = <any> 'REQUEST_URI_TOO_LONG',
        RESETCONTENT = <any> 'RESET_CONTENT',
        SEEOTHER = <any> 'SEE_OTHER',
        SERVICEUNAVAILABLE = <any> 'SERVICE_UNAVAILABLE',
        SWITCHINGPROTOCOLS = <any> 'SWITCHING_PROTOCOLS',
        TEMPORARYREDIRECT = <any> 'TEMPORARY_REDIRECT',
        TOOEARLY = <any> 'TOO_EARLY',
        TOOMANYREQUESTS = <any> 'TOO_MANY_REQUESTS',
        UNAUTHORIZED = <any> 'UNAUTHORIZED',
        UNAVAILABLEFORLEGALREASONS = <any> 'UNAVAILABLE_FOR_LEGAL_REASONS',
        UNPROCESSABLEENTITY = <any> 'UNPROCESSABLE_ENTITY',
        UNSUPPORTEDMEDIATYPE = <any> 'UNSUPPORTED_MEDIA_TYPE',
        UPGRADEREQUIRED = <any> 'UPGRADE_REQUIRED',
        URITOOLONG = <any> 'URI_TOO_LONG',
        USEPROXY = <any> 'USE_PROXY',
        VARIANTALSONEGOTIATES = <any> 'VARIANT_ALSO_NEGOTIATES'
    }
}

/**
 * 
 * @export
 * @interface ModifyableTags
 */
export interface ModifyableTags {
    /**
     * 
     * @type {string}
     * @memberof ModifyableTags
     */
    htmlType?: ModifyableTags.HtmlTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ModifyableTags
     */
    propertyName?: string;
    /**
     * 
     * @type {SQLType}
     * @memberof ModifyableTags
     */
    sqlType?: SQLType;
}

/**
 * @export
 * @namespace ModifyableTags
 */
export namespace ModifyableTags {
    /**
     * @export
     * @enum {string}
     */
    export enum HtmlTypeEnum {
        Number = <any> 'number',
        Text = <any> 'text'
    }
}

/**
 * 
 * @export
 * @interface PlaylistReq
 */
export interface PlaylistReq {
    /**
     * 
     * @type {Date}
     * @memberof PlaylistReq
     */
    dateCreated?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PlaylistReq
     */
    dateUpdated?: Date;
    /**
     * 
     * @type {number}
     * @memberof PlaylistReq
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PlaylistReq
     */
    name: string;
    /**
     * 
     * @type {Array<PlaylistTrack>}
     * @memberof PlaylistReq
     */
    trackIds?: Array<PlaylistTrack>;
}

/**
 * 
 * @export
 * @interface PlaylistRes
 */
export interface PlaylistRes {
    /**
     * 
     * @type {Date}
     * @memberof PlaylistRes
     */
    dateCreated: Date;
    /**
     * 
     * @type {Date}
     * @memberof PlaylistRes
     */
    dateUpdated?: Date;
    /**
     * 
     * @type {number}
     * @memberof PlaylistRes
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof PlaylistRes
     */
    name: string;
    /**
     * 
     * @type {Array<PlaylistTrack>}
     * @memberof PlaylistRes
     */
    trackIds: Array<PlaylistTrack>;
}

/**
 * 
 * @export
 * @interface PlaylistTrack
 */
export interface PlaylistTrack {
    /**
     * 
     * @type {Date}
     * @memberof PlaylistTrack
     */
    dateAdded: Date;
    /**
     * 
     * @type {number}
     * @memberof PlaylistTrack
     */
    playlistId?: number;
    /**
     * 
     * @type {number}
     * @memberof PlaylistTrack
     */
    sequenceId?: number;
    /**
     * 
     * @type {number}
     * @memberof PlaylistTrack
     */
    trackId?: number;
}

/**
 * 
 * @export
 * @interface Resource
 */
export interface Resource {
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    description?: string;
    /**
     * 
     * @type {any}
     * @memberof Resource
     */
    file?: any;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    filename?: string;
    /**
     * 
     * @type {InputStream}
     * @memberof Resource
     */
    inputStream?: InputStream;
    /**
     * 
     * @type {boolean}
     * @memberof Resource
     */
    open?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Resource
     */
    readable?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface SQLType
 */
export interface SQLType {
    /**
     * 
     * @type {string}
     * @memberof SQLType
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SQLType
     */
    vendor?: string;
    /**
     * 
     * @type {number}
     * @memberof SQLType
     */
    vendorTypeNumber?: number;
}

/**
 * 
 * @export
 * @interface SmartPlaylistReq
 */
export interface SmartPlaylistReq {
    /**
     * 
     * @type {Date}
     * @memberof SmartPlaylistReq
     */
    dateCreated?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SmartPlaylistReq
     */
    dateUpdated?: Date;
    /**
     * 
     * @type {string}
     * @memberof SmartPlaylistReq
     */
    dynamicSql: string;
    /**
     * 
     * @type {number}
     * @memberof SmartPlaylistReq
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof SmartPlaylistReq
     */
    name: string;
}

/**
 * 
 * @export
 * @interface SmartPlaylistRes
 */
export interface SmartPlaylistRes {
    /**
     * 
     * @type {Date}
     * @memberof SmartPlaylistRes
     */
    dateCreated: Date;
    /**
     * 
     * @type {Date}
     * @memberof SmartPlaylistRes
     */
    dateUpdated?: Date;
    /**
     * 
     * @type {string}
     * @memberof SmartPlaylistRes
     */
    dynamicSql: string;
    /**
     * 
     * @type {number}
     * @memberof SmartPlaylistRes
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof SmartPlaylistRes
     */
    name: string;
}

/**
 * 
 * @export
 * @interface SyncResult
 */
export interface SyncResult {
    /**
     * 
     * @type {Array<DeferredTrack>}
     * @memberof SyncResult
     */
    failedTracks: Array<DeferredTrack>;
    /**
     * 
     * @type {Array<DeferredTrack>}
     * @memberof SyncResult
     */
    modifiedTracks: Array<DeferredTrack>;
    /**
     * 
     * @type {Array<DeferredTrack>}
     * @memberof SyncResult
     */
    newTracks: Array<DeferredTrack>;
    /**
     * 
     * @type {Array<Track>}
     * @memberof SyncResult
     */
    orphanedTracks: Array<Track>;
    /**
     * 
     * @type {Array<DeferredTrack>}
     * @memberof SyncResult
     */
    unmodifiedTracks: Array<DeferredTrack>;
    /**
     * 
     * @type {Array<Track>}
     * @memberof SyncResult
     */
    unorphanedTracks: Array<Track>;
}

/**
 * 
 * @export
 * @interface Track
 */
export interface Track {
    /**
     * 
     * @type {string}
     * @memberof Track
     */
    album?: string;
    /**
     * 
     * @type {string}
     * @memberof Track
     */
    albumArtist?: string;
    /**
     * 
     * @type {string}
     * @memberof Track
     */
    artist?: string;
    /**
     * 
     * @type {number}
     * @memberof Track
     */
    bitrate?: number;
    /**
     * 
     * @type {string}
     * @memberof Track
     */
    comment?: string;
    /**
     * 
     * @type {Date}
     * @memberof Track
     */
    dateCreated?: Date;
    /**
     * 
     * @type {number}
     * @memberof Track
     */
    discNo?: number;
    /**
     * 
     * @type {number}
     * @memberof Track
     */
    duration?: number;
    /**
     * 
     * @type {string}
     * @memberof Track
     */
    encoding?: string;
    /**
     * 
     * @type {string}
     * @memberof Track
     */
    genre?: string;
    /**
     * 
     * @type {string}
     * @memberof Track
     */
    hash?: string;
    /**
     * 
     * @type {number}
     * @memberof Track
     */
    id: number;
    /**
     * 
     * @type {Date}
     * @memberof Track
     */
    lastPlayedDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof Track
     */
    location?: string;
    /**
     * 
     * @type {number}
     * @memberof Track
     */
    plays?: number;
    /**
     * 
     * @type {number}
     * @memberof Track
     */
    rating?: number;
    /**
     * 
     * @type {number}
     * @memberof Track
     */
    sampleRate?: number;
    /**
     * 
     * @type {number}
     * @memberof Track
     */
    skips?: number;
    /**
     * 
     * @type {string}
     * @memberof Track
     */
    title?: string;
    /**
     * 
     * @type {number}
     * @memberof Track
     */
    track?: number;
    /**
     * 
     * @type {string}
     * @memberof Track
     */
    year?: string;
}

/**
 * 
 * @export
 * @interface View
 */
export interface View {
    /**
     * 
     * @type {string}
     * @memberof View
     */
    contentType?: string;
}


/**
 * AdminEndpointApi - fetch parameter creator
 * @export
 */
export const AdminEndpointApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary applyUpdatesToSongs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyUpdatesToSongsUsingPOST(options: any = {}): FetchArgs {
            const localVarPath = `/Music/admin/update`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary countPurgableTracks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countPurgableTracksUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/Music/admin/purge/count`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary countUpdates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countUpdatesUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/Music/admin/update/count`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listOrphanedFiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrphanedFilesUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/Music/admin/orphanedFiles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listPurgableTracks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPurgableTracksUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/Music/admin/purge`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary purgeDeletedTracks
         * @param {Array<number>} [tracksToDelete] tracksToDelete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeDeletedTracksUsingDELETE(tracksToDelete?: Array<number>, options: any = {}): FetchArgs {
            const localVarPath = `/Music/admin/purge`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;number&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tracksToDelete || {}) : (tracksToDelete || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary purgeInto
         * @param {number} existingId existingId
         * @param {number} idToDelete idToDelete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeIntoUsingDELETE(existingId: number, idToDelete: number, options: any = {}): FetchArgs {
            // verify required parameter 'existingId' is not null or undefined
            if (existingId === null || existingId === undefined) {
                throw new RequiredError('existingId','Required parameter existingId was null or undefined when calling purgeIntoUsingDELETE.');
            }
            // verify required parameter 'idToDelete' is not null or undefined
            if (idToDelete === null || idToDelete === undefined) {
                throw new RequiredError('idToDelete','Required parameter idToDelete was null or undefined when calling purgeIntoUsingDELETE.');
            }
            const localVarPath = `/Music/admin/purge/{idToDelete}/into/{existingId}`
                .replace(`{${"existingId"}}`, encodeURIComponent(String(existingId)))
                .replace(`{${"idToDelete"}}`, encodeURIComponent(String(idToDelete)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary syncTracksToDb
         * @param {number} libraryId libraryId
         * @param {boolean} [forceUpdates] forceUpdates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncTracksToDbUsingPOST(libraryId: number, forceUpdates?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'libraryId' is not null or undefined
            if (libraryId === null || libraryId === undefined) {
                throw new RequiredError('libraryId','Required parameter libraryId was null or undefined when calling syncTracksToDbUsingPOST.');
            }
            const localVarPath = `/Music/admin/dbSync`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (forceUpdates !== undefined) {
                localVarQueryParameter['forceUpdates'] = forceUpdates;
            }

            if (libraryId !== undefined) {
                localVarQueryParameter['libraryId'] = libraryId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminEndpointApi - functional programming interface
 * @export
 */
export const AdminEndpointApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary applyUpdatesToSongs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyUpdatesToSongsUsingPOST(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminEndpointApiFetchParamCreator(configuration).applyUpdatesToSongsUsingPOST(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary countPurgableTracks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countPurgableTracksUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = AdminEndpointApiFetchParamCreator(configuration).countPurgableTracksUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary countUpdates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countUpdatesUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = AdminEndpointApiFetchParamCreator(configuration).countUpdatesUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary listOrphanedFiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrphanedFilesUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
            const localVarFetchArgs = AdminEndpointApiFetchParamCreator(configuration).listOrphanedFilesUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary listPurgableTracks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPurgableTracksUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Track>> {
            const localVarFetchArgs = AdminEndpointApiFetchParamCreator(configuration).listPurgableTracksUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary purgeDeletedTracks
         * @param {Array<number>} [tracksToDelete] tracksToDelete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeDeletedTracksUsingDELETE(tracksToDelete?: Array<number>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Track>> {
            const localVarFetchArgs = AdminEndpointApiFetchParamCreator(configuration).purgeDeletedTracksUsingDELETE(tracksToDelete, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary purgeInto
         * @param {number} existingId existingId
         * @param {number} idToDelete idToDelete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeIntoUsingDELETE(existingId: number, idToDelete: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Track>> {
            const localVarFetchArgs = AdminEndpointApiFetchParamCreator(configuration).purgeIntoUsingDELETE(existingId, idToDelete, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary syncTracksToDb
         * @param {number} libraryId libraryId
         * @param {boolean} [forceUpdates] forceUpdates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncTracksToDbUsingPOST(libraryId: number, forceUpdates?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SyncResult> {
            const localVarFetchArgs = AdminEndpointApiFetchParamCreator(configuration).syncTracksToDbUsingPOST(libraryId, forceUpdates, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AdminEndpointApi - factory interface
 * @export
 */
export const AdminEndpointApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary applyUpdatesToSongs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyUpdatesToSongsUsingPOST(options?: any) {
            return AdminEndpointApiFp(configuration).applyUpdatesToSongsUsingPOST(options)(fetch, basePath);
        },
        /**
         * 
         * @summary countPurgableTracks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countPurgableTracksUsingGET(options?: any) {
            return AdminEndpointApiFp(configuration).countPurgableTracksUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary countUpdates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countUpdatesUsingGET(options?: any) {
            return AdminEndpointApiFp(configuration).countUpdatesUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary listOrphanedFiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrphanedFilesUsingGET(options?: any) {
            return AdminEndpointApiFp(configuration).listOrphanedFilesUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary listPurgableTracks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPurgableTracksUsingGET(options?: any) {
            return AdminEndpointApiFp(configuration).listPurgableTracksUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary purgeDeletedTracks
         * @param {Array<number>} [tracksToDelete] tracksToDelete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeDeletedTracksUsingDELETE(tracksToDelete?: Array<number>, options?: any) {
            return AdminEndpointApiFp(configuration).purgeDeletedTracksUsingDELETE(tracksToDelete, options)(fetch, basePath);
        },
        /**
         * 
         * @summary purgeInto
         * @param {number} existingId existingId
         * @param {number} idToDelete idToDelete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeIntoUsingDELETE(existingId: number, idToDelete: number, options?: any) {
            return AdminEndpointApiFp(configuration).purgeIntoUsingDELETE(existingId, idToDelete, options)(fetch, basePath);
        },
        /**
         * 
         * @summary syncTracksToDb
         * @param {number} libraryId libraryId
         * @param {boolean} [forceUpdates] forceUpdates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncTracksToDbUsingPOST(libraryId: number, forceUpdates?: boolean, options?: any) {
            return AdminEndpointApiFp(configuration).syncTracksToDbUsingPOST(libraryId, forceUpdates, options)(fetch, basePath);
        },
    };
};

/**
 * AdminEndpointApi - object-oriented interface
 * @export
 * @class AdminEndpointApi
 * @extends {BaseAPI}
 */
export class AdminEndpointApi extends BaseAPI {
    /**
     * 
     * @summary applyUpdatesToSongs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminEndpointApi
     */
    public applyUpdatesToSongsUsingPOST(options?: any) {
        return AdminEndpointApiFp(this.configuration).applyUpdatesToSongsUsingPOST(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary countPurgableTracks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminEndpointApi
     */
    public countPurgableTracksUsingGET(options?: any) {
        return AdminEndpointApiFp(this.configuration).countPurgableTracksUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary countUpdates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminEndpointApi
     */
    public countUpdatesUsingGET(options?: any) {
        return AdminEndpointApiFp(this.configuration).countUpdatesUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary listOrphanedFiles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminEndpointApi
     */
    public listOrphanedFilesUsingGET(options?: any) {
        return AdminEndpointApiFp(this.configuration).listOrphanedFilesUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary listPurgableTracks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminEndpointApi
     */
    public listPurgableTracksUsingGET(options?: any) {
        return AdminEndpointApiFp(this.configuration).listPurgableTracksUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary purgeDeletedTracks
     * @param {Array<number>} [tracksToDelete] tracksToDelete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminEndpointApi
     */
    public purgeDeletedTracksUsingDELETE(tracksToDelete?: Array<number>, options?: any) {
        return AdminEndpointApiFp(this.configuration).purgeDeletedTracksUsingDELETE(tracksToDelete, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary purgeInto
     * @param {number} existingId existingId
     * @param {number} idToDelete idToDelete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminEndpointApi
     */
    public purgeIntoUsingDELETE(existingId: number, idToDelete: number, options?: any) {
        return AdminEndpointApiFp(this.configuration).purgeIntoUsingDELETE(existingId, idToDelete, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary syncTracksToDb
     * @param {number} libraryId libraryId
     * @param {boolean} [forceUpdates] forceUpdates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminEndpointApi
     */
    public syncTracksToDbUsingPOST(libraryId: number, forceUpdates?: boolean, options?: any) {
        return AdminEndpointApiFp(this.configuration).syncTracksToDbUsingPOST(libraryId, forceUpdates, options)(this.fetch, this.basePath);
    }

}

/**
 * BasicErrorControllerApi - fetch parameter creator
 * @export
 */
export const BasicErrorControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE(options: any = {}): FetchArgs {
            const localVarPath = `/Music/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/Music/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD(options: any = {}): FetchArgs {
            const localVarPath = `/Music/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS(options: any = {}): FetchArgs {
            const localVarPath = `/Music/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'OPTIONS' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH(options: any = {}): FetchArgs {
            const localVarPath = `/Music/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST(options: any = {}): FetchArgs {
            const localVarPath = `/Music/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT(options: any = {}): FetchArgs {
            const localVarPath = `/Music/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BasicErrorControllerApi - functional programming interface
 * @export
 */
export const BasicErrorControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingDELETE(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingHEAD(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingOPTIONS(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingPATCH(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingPOST(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingPUT(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BasicErrorControllerApi - factory interface
 * @export
 */
export const BasicErrorControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingDELETE(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingHEAD(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingOPTIONS(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingPATCH(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingPOST(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingPUT(options)(fetch, basePath);
        },
    };
};

/**
 * BasicErrorControllerApi - object-oriented interface
 * @export
 * @class BasicErrorControllerApi
 * @extends {BaseAPI}
 */
export class BasicErrorControllerApi extends BaseAPI {
    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingDELETE(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingDELETE(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingGET(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingHEAD(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingHEAD(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingOPTIONS(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingOPTIONS(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPATCH(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPATCH(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPOST(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPOST(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPUT(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPUT(options)(this.fetch, this.basePath);
    }

}

/**
 * ConvertEndpointApi - fetch parameter creator
 * @export
 */
export const ConvertEndpointApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getHashOfConvertedDeviceFile
         * @param {string} deviceName deviceName
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHashOfConvertedDeviceFileUsingGET(deviceName: string, trackId: number, options: any = {}): FetchArgs {
            // verify required parameter 'deviceName' is not null or undefined
            if (deviceName === null || deviceName === undefined) {
                throw new RequiredError('deviceName','Required parameter deviceName was null or undefined when calling getHashOfConvertedDeviceFileUsingGET.');
            }
            // verify required parameter 'trackId' is not null or undefined
            if (trackId === null || trackId === undefined) {
                throw new RequiredError('trackId','Required parameter trackId was null or undefined when calling getHashOfConvertedDeviceFileUsingGET.');
            }
            const localVarPath = `/Music/convert/{trackId}/hash`
                .replace(`{${"trackId"}}`, encodeURIComponent(String(trackId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deviceName !== undefined) {
                localVarQueryParameter['deviceName'] = deviceName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConvertEndpointApi - functional programming interface
 * @export
 */
export const ConvertEndpointApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getHashOfConvertedDeviceFile
         * @param {string} deviceName deviceName
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHashOfConvertedDeviceFileUsingGET(deviceName: string, trackId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = ConvertEndpointApiFetchParamCreator(configuration).getHashOfConvertedDeviceFileUsingGET(deviceName, trackId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConvertEndpointApi - factory interface
 * @export
 */
export const ConvertEndpointApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getHashOfConvertedDeviceFile
         * @param {string} deviceName deviceName
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHashOfConvertedDeviceFileUsingGET(deviceName: string, trackId: number, options?: any) {
            return ConvertEndpointApiFp(configuration).getHashOfConvertedDeviceFileUsingGET(deviceName, trackId, options)(fetch, basePath);
        },
    };
};

/**
 * ConvertEndpointApi - object-oriented interface
 * @export
 * @class ConvertEndpointApi
 * @extends {BaseAPI}
 */
export class ConvertEndpointApi extends BaseAPI {
    /**
     * 
     * @summary getHashOfConvertedDeviceFile
     * @param {string} deviceName deviceName
     * @param {number} trackId trackId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConvertEndpointApi
     */
    public getHashOfConvertedDeviceFileUsingGET(deviceName: string, trackId: number, options?: any) {
        return ConvertEndpointApiFp(this.configuration).getHashOfConvertedDeviceFileUsingGET(deviceName, trackId, options)(this.fetch, this.basePath);
    }

}

/**
 * DeviceEndpointApi - fetch parameter creator
 * @export
 */
export const DeviceEndpointApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getDeviceByName
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceByNameUsingGET(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getDeviceByNameUsingGET.');
            }
            const localVarPath = `/Music/device/name/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceEndpointApi - functional programming interface
 * @export
 */
export const DeviceEndpointApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getDeviceByName
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceByNameUsingGET(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Device> {
            const localVarFetchArgs = DeviceEndpointApiFetchParamCreator(configuration).getDeviceByNameUsingGET(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DeviceEndpointApi - factory interface
 * @export
 */
export const DeviceEndpointApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getDeviceByName
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceByNameUsingGET(name: string, options?: any) {
            return DeviceEndpointApiFp(configuration).getDeviceByNameUsingGET(name, options)(fetch, basePath);
        },
    };
};

/**
 * DeviceEndpointApi - object-oriented interface
 * @export
 * @class DeviceEndpointApi
 * @extends {BaseAPI}
 */
export class DeviceEndpointApi extends BaseAPI {
    /**
     * 
     * @summary getDeviceByName
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceEndpointApi
     */
    public getDeviceByNameUsingGET(name: string, options?: any) {
        return DeviceEndpointApiFp(this.configuration).getDeviceByNameUsingGET(name, options)(this.fetch, this.basePath);
    }

}

/**
 * LibraryEndpointApi - fetch parameter creator
 * @export
 */
export const LibraryEndpointApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/Music/library`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LibraryEndpointApi - functional programming interface
 * @export
 */
export const LibraryEndpointApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Library>> {
            const localVarFetchArgs = LibraryEndpointApiFetchParamCreator(configuration).listUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LibraryEndpointApi - factory interface
 * @export
 */
export const LibraryEndpointApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsingGET(options?: any) {
            return LibraryEndpointApiFp(configuration).listUsingGET(options)(fetch, basePath);
        },
    };
};

/**
 * LibraryEndpointApi - object-oriented interface
 * @export
 * @class LibraryEndpointApi
 * @extends {BaseAPI}
 */
export class LibraryEndpointApi extends BaseAPI {
    /**
     * 
     * @summary list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryEndpointApi
     */
    public listUsingGET(options?: any) {
        return LibraryEndpointApiFp(this.configuration).listUsingGET(options)(this.fetch, this.basePath);
    }

}

/**
 * MigrationEndpointApi - fetch parameter creator
 * @export
 */
export const MigrationEndpointApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary doImport
         * @param {string} deviceName deviceName
         * @param {string} file file
         * @param {boolean} [importPlays] importPlays
         * @param {boolean} [importRatings] importRatings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doImportUsingPOST(deviceName: string, file: string, importPlays?: boolean, importRatings?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'deviceName' is not null or undefined
            if (deviceName === null || deviceName === undefined) {
                throw new RequiredError('deviceName','Required parameter deviceName was null or undefined when calling doImportUsingPOST.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling doImportUsingPOST.');
            }
            const localVarPath = `/Music/migration/import`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deviceName !== undefined) {
                localVarQueryParameter['deviceName'] = deviceName;
            }

            if (importPlays !== undefined) {
                localVarQueryParameter['importPlays'] = importPlays;
            }

            if (importRatings !== undefined) {
                localVarQueryParameter['importRatings'] = importRatings;
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(file || {}) : (file || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MigrationEndpointApi - functional programming interface
 * @export
 */
export const MigrationEndpointApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary doImport
         * @param {string} deviceName deviceName
         * @param {string} file file
         * @param {boolean} [importPlays] importPlays
         * @param {boolean} [importRatings] importRatings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doImportUsingPOST(deviceName: string, file: string, importPlays?: boolean, importRatings?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MigrationResult> {
            const localVarFetchArgs = MigrationEndpointApiFetchParamCreator(configuration).doImportUsingPOST(deviceName, file, importPlays, importRatings, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MigrationEndpointApi - factory interface
 * @export
 */
export const MigrationEndpointApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary doImport
         * @param {string} deviceName deviceName
         * @param {string} file file
         * @param {boolean} [importPlays] importPlays
         * @param {boolean} [importRatings] importRatings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doImportUsingPOST(deviceName: string, file: string, importPlays?: boolean, importRatings?: boolean, options?: any) {
            return MigrationEndpointApiFp(configuration).doImportUsingPOST(deviceName, file, importPlays, importRatings, options)(fetch, basePath);
        },
    };
};

/**
 * MigrationEndpointApi - object-oriented interface
 * @export
 * @class MigrationEndpointApi
 * @extends {BaseAPI}
 */
export class MigrationEndpointApi extends BaseAPI {
    /**
     * 
     * @summary doImport
     * @param {string} deviceName deviceName
     * @param {string} file file
     * @param {boolean} [importPlays] importPlays
     * @param {boolean} [importRatings] importRatings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MigrationEndpointApi
     */
    public doImportUsingPOST(deviceName: string, file: string, importPlays?: boolean, importRatings?: boolean, options?: any) {
        return MigrationEndpointApiFp(this.configuration).doImportUsingPOST(deviceName, file, importPlays, importRatings, options)(this.fetch, this.basePath);
    }

}

/**
 * PlaylistEndpointApi - fetch parameter creator
 * @export
 */
export const PlaylistEndpointApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addTrackToPlaylist
         * @param {number} id id
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTrackToPlaylistUsingPATCH(id: number, trackId: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addTrackToPlaylistUsingPATCH.');
            }
            // verify required parameter 'trackId' is not null or undefined
            if (trackId === null || trackId === undefined) {
                throw new RequiredError('trackId','Required parameter trackId was null or undefined when calling addTrackToPlaylistUsingPATCH.');
            }
            const localVarPath = `/Music/playlist/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (trackId !== undefined) {
                localVarQueryParameter['trackId'] = trackId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create
         * @param {PlaylistReq} playlist playlist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsingPOST(playlist: PlaylistReq, options: any = {}): FetchArgs {
            // verify required parameter 'playlist' is not null or undefined
            if (playlist === null || playlist === undefined) {
                throw new RequiredError('playlist','Required parameter playlist was null or undefined when calling createUsingPOST.');
            }
            const localVarPath = `/Music/playlist`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PlaylistReq" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(playlist || {}) : (playlist || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getById
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByIdUsingGET(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getByIdUsingGET.');
            }
            const localVarPath = `/Music/playlist/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsingGET1(options: any = {}): FetchArgs {
            const localVarPath = `/Music/playlist`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaylistEndpointApi - functional programming interface
 * @export
 */
export const PlaylistEndpointApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addTrackToPlaylist
         * @param {number} id id
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTrackToPlaylistUsingPATCH(id: number, trackId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PlaylistRes> {
            const localVarFetchArgs = PlaylistEndpointApiFetchParamCreator(configuration).addTrackToPlaylistUsingPATCH(id, trackId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary create
         * @param {PlaylistReq} playlist playlist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsingPOST(playlist: PlaylistReq, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PlaylistRes> {
            const localVarFetchArgs = PlaylistEndpointApiFetchParamCreator(configuration).createUsingPOST(playlist, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getById
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByIdUsingGET(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PlaylistRes> {
            const localVarFetchArgs = PlaylistEndpointApiFetchParamCreator(configuration).getByIdUsingGET(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsingGET1(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PlaylistRes>> {
            const localVarFetchArgs = PlaylistEndpointApiFetchParamCreator(configuration).listUsingGET1(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PlaylistEndpointApi - factory interface
 * @export
 */
export const PlaylistEndpointApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary addTrackToPlaylist
         * @param {number} id id
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTrackToPlaylistUsingPATCH(id: number, trackId: number, options?: any) {
            return PlaylistEndpointApiFp(configuration).addTrackToPlaylistUsingPATCH(id, trackId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary create
         * @param {PlaylistReq} playlist playlist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsingPOST(playlist: PlaylistReq, options?: any) {
            return PlaylistEndpointApiFp(configuration).createUsingPOST(playlist, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getById
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByIdUsingGET(id: number, options?: any) {
            return PlaylistEndpointApiFp(configuration).getByIdUsingGET(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsingGET1(options?: any) {
            return PlaylistEndpointApiFp(configuration).listUsingGET1(options)(fetch, basePath);
        },
    };
};

/**
 * PlaylistEndpointApi - object-oriented interface
 * @export
 * @class PlaylistEndpointApi
 * @extends {BaseAPI}
 */
export class PlaylistEndpointApi extends BaseAPI {
    /**
     * 
     * @summary addTrackToPlaylist
     * @param {number} id id
     * @param {number} trackId trackId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEndpointApi
     */
    public addTrackToPlaylistUsingPATCH(id: number, trackId: number, options?: any) {
        return PlaylistEndpointApiFp(this.configuration).addTrackToPlaylistUsingPATCH(id, trackId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary create
     * @param {PlaylistReq} playlist playlist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEndpointApi
     */
    public createUsingPOST(playlist: PlaylistReq, options?: any) {
        return PlaylistEndpointApiFp(this.configuration).createUsingPOST(playlist, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getById
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEndpointApi
     */
    public getByIdUsingGET(id: number, options?: any) {
        return PlaylistEndpointApiFp(this.configuration).getByIdUsingGET(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEndpointApi
     */
    public listUsingGET1(options?: any) {
        return PlaylistEndpointApiFp(this.configuration).listUsingGET1(options)(this.fetch, this.basePath);
    }

}

/**
 * SmartPlaylistEndpointApi - fetch parameter creator
 * @export
 */
export const SmartPlaylistEndpointApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary create
         * @param {SmartPlaylistReq} smartPlaylist smartPlaylist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsingPOST1(smartPlaylist: SmartPlaylistReq, options: any = {}): FetchArgs {
            // verify required parameter 'smartPlaylist' is not null or undefined
            if (smartPlaylist === null || smartPlaylist === undefined) {
                throw new RequiredError('smartPlaylist','Required parameter smartPlaylist was null or undefined when calling createUsingPOST1.');
            }
            const localVarPath = `/Music/playlist/smart`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SmartPlaylistReq" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(smartPlaylist || {}) : (smartPlaylist || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsingDELETE(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteUsingDELETE.');
            }
            const localVarPath = `/Music/playlist/smart/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsingGET(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getUsingGET.');
            }
            const localVarPath = `/Music/playlist/smart/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsingGET2(options: any = {}): FetchArgs {
            const localVarPath = `/Music/playlist/smart`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update
         * @param {SmartPlaylistReq} smartPlaylist smartPlaylist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsingPATCH(smartPlaylist: SmartPlaylistReq, options: any = {}): FetchArgs {
            // verify required parameter 'smartPlaylist' is not null or undefined
            if (smartPlaylist === null || smartPlaylist === undefined) {
                throw new RequiredError('smartPlaylist','Required parameter smartPlaylist was null or undefined when calling updateUsingPATCH.');
            }
            const localVarPath = `/Music/playlist/smart`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SmartPlaylistReq" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(smartPlaylist || {}) : (smartPlaylist || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SmartPlaylistEndpointApi - functional programming interface
 * @export
 */
export const SmartPlaylistEndpointApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary create
         * @param {SmartPlaylistReq} smartPlaylist smartPlaylist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsingPOST1(smartPlaylist: SmartPlaylistReq, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SmartPlaylistRes> {
            const localVarFetchArgs = SmartPlaylistEndpointApiFetchParamCreator(configuration).createUsingPOST1(smartPlaylist, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary delete
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsingDELETE(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SmartPlaylistRes> {
            const localVarFetchArgs = SmartPlaylistEndpointApiFetchParamCreator(configuration).deleteUsingDELETE(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary get
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsingGET(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SmartPlaylistRes> {
            const localVarFetchArgs = SmartPlaylistEndpointApiFetchParamCreator(configuration).getUsingGET(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsingGET2(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SmartPlaylistRes>> {
            const localVarFetchArgs = SmartPlaylistEndpointApiFetchParamCreator(configuration).listUsingGET2(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary update
         * @param {SmartPlaylistReq} smartPlaylist smartPlaylist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsingPATCH(smartPlaylist: SmartPlaylistReq, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SmartPlaylistRes> {
            const localVarFetchArgs = SmartPlaylistEndpointApiFetchParamCreator(configuration).updateUsingPATCH(smartPlaylist, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SmartPlaylistEndpointApi - factory interface
 * @export
 */
export const SmartPlaylistEndpointApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary create
         * @param {SmartPlaylistReq} smartPlaylist smartPlaylist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsingPOST1(smartPlaylist: SmartPlaylistReq, options?: any) {
            return SmartPlaylistEndpointApiFp(configuration).createUsingPOST1(smartPlaylist, options)(fetch, basePath);
        },
        /**
         * 
         * @summary delete
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsingDELETE(id: number, options?: any) {
            return SmartPlaylistEndpointApiFp(configuration).deleteUsingDELETE(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary get
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsingGET(id: number, options?: any) {
            return SmartPlaylistEndpointApiFp(configuration).getUsingGET(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsingGET2(options?: any) {
            return SmartPlaylistEndpointApiFp(configuration).listUsingGET2(options)(fetch, basePath);
        },
        /**
         * 
         * @summary update
         * @param {SmartPlaylistReq} smartPlaylist smartPlaylist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsingPATCH(smartPlaylist: SmartPlaylistReq, options?: any) {
            return SmartPlaylistEndpointApiFp(configuration).updateUsingPATCH(smartPlaylist, options)(fetch, basePath);
        },
    };
};

/**
 * SmartPlaylistEndpointApi - object-oriented interface
 * @export
 * @class SmartPlaylistEndpointApi
 * @extends {BaseAPI}
 */
export class SmartPlaylistEndpointApi extends BaseAPI {
    /**
     * 
     * @summary create
     * @param {SmartPlaylistReq} smartPlaylist smartPlaylist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartPlaylistEndpointApi
     */
    public createUsingPOST1(smartPlaylist: SmartPlaylistReq, options?: any) {
        return SmartPlaylistEndpointApiFp(this.configuration).createUsingPOST1(smartPlaylist, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary delete
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartPlaylistEndpointApi
     */
    public deleteUsingDELETE(id: number, options?: any) {
        return SmartPlaylistEndpointApiFp(this.configuration).deleteUsingDELETE(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary get
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartPlaylistEndpointApi
     */
    public getUsingGET(id: number, options?: any) {
        return SmartPlaylistEndpointApiFp(this.configuration).getUsingGET(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartPlaylistEndpointApi
     */
    public listUsingGET2(options?: any) {
        return SmartPlaylistEndpointApiFp(this.configuration).listUsingGET2(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary update
     * @param {SmartPlaylistReq} smartPlaylist smartPlaylist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartPlaylistEndpointApi
     */
    public updateUsingPATCH(smartPlaylist: SmartPlaylistReq, options?: any) {
        return SmartPlaylistEndpointApiFp(this.configuration).updateUsingPATCH(smartPlaylist, options)(this.fetch, this.basePath);
    }

}

/**
 * TrackEndpointApi - fetch parameter creator
 * @export
 */
export const TrackEndpointApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary delete
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsingDELETE1(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteUsingDELETE1.');
            }
            const localVarPath = `/Music/track/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAlbumArt
         * @param {number} id id
         * @param {number} [index] index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumArtUsingGET(id: number, index?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAlbumArtUsingGET.');
            }
            const localVarPath = `/Music/track/{id}/art`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (index !== undefined) {
                localVarQueryParameter['index'] = index;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listHistoricalDates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHistoricalDatesUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/Music/track/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listHistoricalPlaysByDate
         * @param {Date} date date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHistoricalPlaysByDateUsingGET(date: Date, options: any = {}): FetchArgs {
            // verify required parameter 'date' is not null or undefined
            if (date === null || date === undefined) {
                throw new RequiredError('date','Required parameter date was null or undefined when calling listHistoricalPlaysByDateUsingGET.');
            }
            const localVarPath = `/Music/track/historical/{date}`
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listModifyableTags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModifyableTagsUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/Music/track/modifyabletags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list
         * @param {number} [libraryId] libraryId
         * @param {number} [playlist] playlist
         * @param {number} [smartPlaylist] smartPlaylist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsingGET3(libraryId?: number, playlist?: number, smartPlaylist?: number, options: any = {}): FetchArgs {
            const localVarPath = `/Music/track`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (libraryId !== undefined) {
                localVarQueryParameter['libraryId'] = libraryId;
            }

            if (playlist !== undefined) {
                localVarQueryParameter['playlist'] = playlist;
            }

            if (smartPlaylist !== undefined) {
                localVarQueryParameter['smartPlaylist'] = smartPlaylist;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary markTrackAsListened
         * @param {string} album album
         * @param {string} artist artist
         * @param {string} deviceName deviceName
         * @param {string} title title
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markTrackAsListenedUsingPOST(album: string, artist: string, deviceName: string, title: string, options: any = {}): FetchArgs {
            // verify required parameter 'album' is not null or undefined
            if (album === null || album === undefined) {
                throw new RequiredError('album','Required parameter album was null or undefined when calling markTrackAsListenedUsingPOST.');
            }
            // verify required parameter 'artist' is not null or undefined
            if (artist === null || artist === undefined) {
                throw new RequiredError('artist','Required parameter artist was null or undefined when calling markTrackAsListenedUsingPOST.');
            }
            // verify required parameter 'deviceName' is not null or undefined
            if (deviceName === null || deviceName === undefined) {
                throw new RequiredError('deviceName','Required parameter deviceName was null or undefined when calling markTrackAsListenedUsingPOST.');
            }
            // verify required parameter 'title' is not null or undefined
            if (title === null || title === undefined) {
                throw new RequiredError('title','Required parameter title was null or undefined when calling markTrackAsListenedUsingPOST.');
            }
            const localVarPath = `/Music/track/{artist}/{album}/{title}/listened`
                .replace(`{${"album"}}`, encodeURIComponent(String(album)))
                .replace(`{${"artist"}}`, encodeURIComponent(String(artist)))
                .replace(`{${"title"}}`, encodeURIComponent(String(title)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deviceName !== undefined) {
                localVarQueryParameter['deviceName'] = deviceName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary markTrackAsListened
         * @param {number} deviceId deviceId
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markTrackAsListenedUsingPOST1(deviceId: number, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling markTrackAsListenedUsingPOST1.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling markTrackAsListenedUsingPOST1.');
            }
            const localVarPath = `/Music/track/{id}/listened`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary markTrackAsSkipped
         * @param {number} deviceId deviceId
         * @param {number} id id
         * @param {number} [secondsPlayed] secondsPlayed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markTrackAsSkippedUsingPOST(deviceId: number, id: number, secondsPlayed?: number, options: any = {}): FetchArgs {
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling markTrackAsSkippedUsingPOST.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling markTrackAsSkippedUsingPOST.');
            }
            const localVarPath = `/Music/track/{id}/skipped`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (secondsPlayed !== undefined) {
                localVarQueryParameter['secondsPlayed'] = secondsPlayed;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary setAlbumArt
         * @param {number} id id
         * @param {boolean} updateForEntireAlbum updateForEntireAlbum
         * @param {string} [file] file
         * @param {string} [url] url
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAlbumArtUsingPOST(id: number, updateForEntireAlbum: boolean, file?: string, url?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling setAlbumArtUsingPOST.');
            }
            // verify required parameter 'updateForEntireAlbum' is not null or undefined
            if (updateForEntireAlbum === null || updateForEntireAlbum === undefined) {
                throw new RequiredError('updateForEntireAlbum','Required parameter updateForEntireAlbum was null or undefined when calling setAlbumArtUsingPOST.');
            }
            const localVarPath = `/Music/track/{id}/art`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (updateForEntireAlbum !== undefined) {
                localVarQueryParameter['updateForEntireAlbum'] = updateForEntireAlbum;
            }

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(file || {}) : (file || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary stream
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamUsingGET1(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling streamUsingGET1.');
            }
            const localVarPath = `/Music/track/{id}/stream`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateRating
         * @param {number} id id
         * @param {number} rating rating
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRatingUsingPATCH(id: number, rating: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateRatingUsingPATCH.');
            }
            // verify required parameter 'rating' is not null or undefined
            if (rating === null || rating === undefined) {
                throw new RequiredError('rating','Required parameter rating was null or undefined when calling updateRatingUsingPATCH.');
            }
            const localVarPath = `/Music/track/{id}/rating/{rating}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"rating"}}`, encodeURIComponent(String(rating)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateTrackInfo
         * @param {Track} track track
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrackInfoUsingPATCH(track: Track, options: any = {}): FetchArgs {
            // verify required parameter 'track' is not null or undefined
            if (track === null || track === undefined) {
                throw new RequiredError('track','Required parameter track was null or undefined when calling updateTrackInfoUsingPATCH.');
            }
            const localVarPath = `/Music/track`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Track" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(track || {}) : (track || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary uploadTrack
         * @param {string} file file
         * @param {number} [existingId] existingId
         * @param {number} [libraryId] libraryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTrackUsingPOST(file: string, existingId?: number, libraryId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling uploadTrackUsingPOST.');
            }
            const localVarPath = `/Music/track/upload`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (existingId !== undefined) {
                localVarQueryParameter['existingId'] = existingId;
            }

            if (libraryId !== undefined) {
                localVarQueryParameter['libraryId'] = libraryId;
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(file || {}) : (file || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrackEndpointApi - functional programming interface
 * @export
 */
export const TrackEndpointApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary delete
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsingDELETE1(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
            const localVarFetchArgs = TrackEndpointApiFetchParamCreator(configuration).deleteUsingDELETE1(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAlbumArt
         * @param {number} id id
         * @param {number} [index] index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumArtUsingGET(id: number, index?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Resource> {
            const localVarFetchArgs = TrackEndpointApiFetchParamCreator(configuration).getAlbumArtUsingGET(id, index, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary listHistoricalDates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHistoricalDatesUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = TrackEndpointApiFetchParamCreator(configuration).listHistoricalDatesUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary listHistoricalPlaysByDate
         * @param {Date} date date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHistoricalPlaysByDateUsingGET(date: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Track>> {
            const localVarFetchArgs = TrackEndpointApiFetchParamCreator(configuration).listHistoricalPlaysByDateUsingGET(date, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary listModifyableTags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModifyableTagsUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ModifyableTags>> {
            const localVarFetchArgs = TrackEndpointApiFetchParamCreator(configuration).listModifyableTagsUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary list
         * @param {number} [libraryId] libraryId
         * @param {number} [playlist] playlist
         * @param {number} [smartPlaylist] smartPlaylist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsingGET3(libraryId?: number, playlist?: number, smartPlaylist?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Track>> {
            const localVarFetchArgs = TrackEndpointApiFetchParamCreator(configuration).listUsingGET3(libraryId, playlist, smartPlaylist, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary markTrackAsListened
         * @param {string} album album
         * @param {string} artist artist
         * @param {string} deviceName deviceName
         * @param {string} title title
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markTrackAsListenedUsingPOST(album: string, artist: string, deviceName: string, title: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
            const localVarFetchArgs = TrackEndpointApiFetchParamCreator(configuration).markTrackAsListenedUsingPOST(album, artist, deviceName, title, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary markTrackAsListened
         * @param {number} deviceId deviceId
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markTrackAsListenedUsingPOST1(deviceId: number, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
            const localVarFetchArgs = TrackEndpointApiFetchParamCreator(configuration).markTrackAsListenedUsingPOST1(deviceId, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary markTrackAsSkipped
         * @param {number} deviceId deviceId
         * @param {number} id id
         * @param {number} [secondsPlayed] secondsPlayed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markTrackAsSkippedUsingPOST(deviceId: number, id: number, secondsPlayed?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
            const localVarFetchArgs = TrackEndpointApiFetchParamCreator(configuration).markTrackAsSkippedUsingPOST(deviceId, id, secondsPlayed, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary setAlbumArt
         * @param {number} id id
         * @param {boolean} updateForEntireAlbum updateForEntireAlbum
         * @param {string} [file] file
         * @param {string} [url] url
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAlbumArtUsingPOST(id: number, updateForEntireAlbum: boolean, file?: string, url?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
            const localVarFetchArgs = TrackEndpointApiFetchParamCreator(configuration).setAlbumArtUsingPOST(id, updateForEntireAlbum, file, url, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary stream
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamUsingGET1(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Resource> {
            const localVarFetchArgs = TrackEndpointApiFetchParamCreator(configuration).streamUsingGET1(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary updateRating
         * @param {number} id id
         * @param {number} rating rating
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRatingUsingPATCH(id: number, rating: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
            const localVarFetchArgs = TrackEndpointApiFetchParamCreator(configuration).updateRatingUsingPATCH(id, rating, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary updateTrackInfo
         * @param {Track} track track
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrackInfoUsingPATCH(track: Track, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
            const localVarFetchArgs = TrackEndpointApiFetchParamCreator(configuration).updateTrackInfoUsingPATCH(track, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary uploadTrack
         * @param {string} file file
         * @param {number} [existingId] existingId
         * @param {number} [libraryId] libraryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTrackUsingPOST(file: string, existingId?: number, libraryId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Track> {
            const localVarFetchArgs = TrackEndpointApiFetchParamCreator(configuration).uploadTrackUsingPOST(file, existingId, libraryId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TrackEndpointApi - factory interface
 * @export
 */
export const TrackEndpointApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary delete
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsingDELETE1(id: number, options?: any) {
            return TrackEndpointApiFp(configuration).deleteUsingDELETE1(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAlbumArt
         * @param {number} id id
         * @param {number} [index] index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumArtUsingGET(id: number, index?: number, options?: any) {
            return TrackEndpointApiFp(configuration).getAlbumArtUsingGET(id, index, options)(fetch, basePath);
        },
        /**
         * 
         * @summary listHistoricalDates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHistoricalDatesUsingGET(options?: any) {
            return TrackEndpointApiFp(configuration).listHistoricalDatesUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary listHistoricalPlaysByDate
         * @param {Date} date date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHistoricalPlaysByDateUsingGET(date: Date, options?: any) {
            return TrackEndpointApiFp(configuration).listHistoricalPlaysByDateUsingGET(date, options)(fetch, basePath);
        },
        /**
         * 
         * @summary listModifyableTags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModifyableTagsUsingGET(options?: any) {
            return TrackEndpointApiFp(configuration).listModifyableTagsUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary list
         * @param {number} [libraryId] libraryId
         * @param {number} [playlist] playlist
         * @param {number} [smartPlaylist] smartPlaylist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsingGET3(libraryId?: number, playlist?: number, smartPlaylist?: number, options?: any) {
            return TrackEndpointApiFp(configuration).listUsingGET3(libraryId, playlist, smartPlaylist, options)(fetch, basePath);
        },
        /**
         * 
         * @summary markTrackAsListened
         * @param {string} album album
         * @param {string} artist artist
         * @param {string} deviceName deviceName
         * @param {string} title title
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markTrackAsListenedUsingPOST(album: string, artist: string, deviceName: string, title: string, options?: any) {
            return TrackEndpointApiFp(configuration).markTrackAsListenedUsingPOST(album, artist, deviceName, title, options)(fetch, basePath);
        },
        /**
         * 
         * @summary markTrackAsListened
         * @param {number} deviceId deviceId
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markTrackAsListenedUsingPOST1(deviceId: number, id: number, options?: any) {
            return TrackEndpointApiFp(configuration).markTrackAsListenedUsingPOST1(deviceId, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary markTrackAsSkipped
         * @param {number} deviceId deviceId
         * @param {number} id id
         * @param {number} [secondsPlayed] secondsPlayed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markTrackAsSkippedUsingPOST(deviceId: number, id: number, secondsPlayed?: number, options?: any) {
            return TrackEndpointApiFp(configuration).markTrackAsSkippedUsingPOST(deviceId, id, secondsPlayed, options)(fetch, basePath);
        },
        /**
         * 
         * @summary setAlbumArt
         * @param {number} id id
         * @param {boolean} updateForEntireAlbum updateForEntireAlbum
         * @param {string} [file] file
         * @param {string} [url] url
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAlbumArtUsingPOST(id: number, updateForEntireAlbum: boolean, file?: string, url?: string, options?: any) {
            return TrackEndpointApiFp(configuration).setAlbumArtUsingPOST(id, updateForEntireAlbum, file, url, options)(fetch, basePath);
        },
        /**
         * 
         * @summary stream
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamUsingGET1(id: number, options?: any) {
            return TrackEndpointApiFp(configuration).streamUsingGET1(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary updateRating
         * @param {number} id id
         * @param {number} rating rating
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRatingUsingPATCH(id: number, rating: number, options?: any) {
            return TrackEndpointApiFp(configuration).updateRatingUsingPATCH(id, rating, options)(fetch, basePath);
        },
        /**
         * 
         * @summary updateTrackInfo
         * @param {Track} track track
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrackInfoUsingPATCH(track: Track, options?: any) {
            return TrackEndpointApiFp(configuration).updateTrackInfoUsingPATCH(track, options)(fetch, basePath);
        },
        /**
         * 
         * @summary uploadTrack
         * @param {string} file file
         * @param {number} [existingId] existingId
         * @param {number} [libraryId] libraryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTrackUsingPOST(file: string, existingId?: number, libraryId?: number, options?: any) {
            return TrackEndpointApiFp(configuration).uploadTrackUsingPOST(file, existingId, libraryId, options)(fetch, basePath);
        },
    };
};

/**
 * TrackEndpointApi - object-oriented interface
 * @export
 * @class TrackEndpointApi
 * @extends {BaseAPI}
 */
export class TrackEndpointApi extends BaseAPI {
    /**
     * 
     * @summary delete
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackEndpointApi
     */
    public deleteUsingDELETE1(id: number, options?: any) {
        return TrackEndpointApiFp(this.configuration).deleteUsingDELETE1(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAlbumArt
     * @param {number} id id
     * @param {number} [index] index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackEndpointApi
     */
    public getAlbumArtUsingGET(id: number, index?: number, options?: any) {
        return TrackEndpointApiFp(this.configuration).getAlbumArtUsingGET(id, index, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary listHistoricalDates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackEndpointApi
     */
    public listHistoricalDatesUsingGET(options?: any) {
        return TrackEndpointApiFp(this.configuration).listHistoricalDatesUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary listHistoricalPlaysByDate
     * @param {Date} date date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackEndpointApi
     */
    public listHistoricalPlaysByDateUsingGET(date: Date, options?: any) {
        return TrackEndpointApiFp(this.configuration).listHistoricalPlaysByDateUsingGET(date, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary listModifyableTags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackEndpointApi
     */
    public listModifyableTagsUsingGET(options?: any) {
        return TrackEndpointApiFp(this.configuration).listModifyableTagsUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary list
     * @param {number} [libraryId] libraryId
     * @param {number} [playlist] playlist
     * @param {number} [smartPlaylist] smartPlaylist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackEndpointApi
     */
    public listUsingGET3(libraryId?: number, playlist?: number, smartPlaylist?: number, options?: any) {
        return TrackEndpointApiFp(this.configuration).listUsingGET3(libraryId, playlist, smartPlaylist, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary markTrackAsListened
     * @param {string} album album
     * @param {string} artist artist
     * @param {string} deviceName deviceName
     * @param {string} title title
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackEndpointApi
     */
    public markTrackAsListenedUsingPOST(album: string, artist: string, deviceName: string, title: string, options?: any) {
        return TrackEndpointApiFp(this.configuration).markTrackAsListenedUsingPOST(album, artist, deviceName, title, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary markTrackAsListened
     * @param {number} deviceId deviceId
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackEndpointApi
     */
    public markTrackAsListenedUsingPOST1(deviceId: number, id: number, options?: any) {
        return TrackEndpointApiFp(this.configuration).markTrackAsListenedUsingPOST1(deviceId, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary markTrackAsSkipped
     * @param {number} deviceId deviceId
     * @param {number} id id
     * @param {number} [secondsPlayed] secondsPlayed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackEndpointApi
     */
    public markTrackAsSkippedUsingPOST(deviceId: number, id: number, secondsPlayed?: number, options?: any) {
        return TrackEndpointApiFp(this.configuration).markTrackAsSkippedUsingPOST(deviceId, id, secondsPlayed, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary setAlbumArt
     * @param {number} id id
     * @param {boolean} updateForEntireAlbum updateForEntireAlbum
     * @param {string} [file] file
     * @param {string} [url] url
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackEndpointApi
     */
    public setAlbumArtUsingPOST(id: number, updateForEntireAlbum: boolean, file?: string, url?: string, options?: any) {
        return TrackEndpointApiFp(this.configuration).setAlbumArtUsingPOST(id, updateForEntireAlbum, file, url, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary stream
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackEndpointApi
     */
    public streamUsingGET1(id: number, options?: any) {
        return TrackEndpointApiFp(this.configuration).streamUsingGET1(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary updateRating
     * @param {number} id id
     * @param {number} rating rating
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackEndpointApi
     */
    public updateRatingUsingPATCH(id: number, rating: number, options?: any) {
        return TrackEndpointApiFp(this.configuration).updateRatingUsingPATCH(id, rating, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary updateTrackInfo
     * @param {Track} track track
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackEndpointApi
     */
    public updateTrackInfoUsingPATCH(track: Track, options?: any) {
        return TrackEndpointApiFp(this.configuration).updateTrackInfoUsingPATCH(track, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary uploadTrack
     * @param {string} file file
     * @param {number} [existingId] existingId
     * @param {number} [libraryId] libraryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackEndpointApi
     */
    public uploadTrackUsingPOST(file: string, existingId?: number, libraryId?: number, options?: any) {
        return TrackEndpointApiFp(this.configuration).uploadTrackUsingPOST(file, existingId, libraryId, options)(this.fetch, this.basePath);
    }

}

